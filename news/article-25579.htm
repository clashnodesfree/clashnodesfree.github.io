<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <link rel="canonical" href="https://clashnodesfree.github.io/news/article-25579.htm" />
<!-- basic -->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<!-- mobile metas -->
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="viewport" content="initial-scale=1, maximum-scale=1">
<!-- site metas -->
<title>FP-growth 算法与Python实现</title>
<meta name="description" content="介绍   打开你的搜索引擎，输入一个单词或一部分，例如“我”，搜索引擎可能会去统计和“我”一块出现得多的词，然后返回给你。其实就是去找频繁项集，而且需要相当地高效，像Apriori那样的速度肯定是不行" />
<!-- bootstrap css -->
<link rel="stylesheet" type="text/css" href="/assets/website/css/clashnodesfree/bootstrap.min.css">
<!-- style css -->
<link rel="stylesheet" type="text/css" href="/assets/website/css/clashnodesfree/style.css">
<!-- Responsive-->
<link rel="stylesheet" href="/assets/website/css/clashnodesfree/responsive.css">
<!-- favicon -->
<link rel="icon" href="/assets/website/img/clashnodesfree/favicon.ico" type="image/x-icon"/>
<!-- Scrollbar Custom CSS -->
<link rel="stylesheet" href="/assets/website/css/clashnodesfree/jquery.mCustomScrollbar.min.css">
<!-- Tweaks for older IEs-->
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.0.3/css/font-awesome.css">
<!-- fonts -->
<link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;500;600;800&family=Sen:wght@400;700;800&display=swap" rel="stylesheet">
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Z348FF31FW"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-Z348FF31FW');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
    <!-- header section start -->
    <div class="header_section header_bg">
        <div class="container-fluid">
                        <nav class="navbar navbar-expand-lg navbar-light bg-light">
                <div class="logo">
                                        <a href="/">Clash Nodes Free</a>
                                    </div>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav ml-auto">
                                                <li class="nav-item">
                            <a class="nav-link" href="/">首页</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/free-nodes/">免费节点</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/paid-subscribe/">推荐机场</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="/news/">新闻资讯</a>
                        </li>
                                                <li class="nav-item">
                            <a class="nav-link" href="#">关于</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="#">联系</a>
                        </li>
                    </ul>
                </div>
            </nav>
        </div>
    </div>
    <!-- header section end -->
    <!-- about sectuion start -->
    <div class="about_section layout_padding">
        <div class="container">
            <div class="breadcrumb">
              <a href="/">首页</a> / 
              <a href="/news/">新闻资讯</a> / 
              <span>正文</span>
            </div>

            <div class="row">
                <div class="col-md-9">
                    <h1 class="services_taital mb-5">FP-growth 算法与Python实现</h1>
                                      				  				  				<div id="content_views" class="markdown_views prism-atom-one-dark"> </h1> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220722/e51823f7b6ba3028760258d41b1ba1f5.jpg" alt="FP-growth 算法与Python实现"></p> <h2 id="介绍">介绍</h2> <p>  打开你的搜索引擎，输入一个单词或一部分，例如“我”，搜索引擎可能会去统计和“我”一块出现得多的词，然后返回给你。其实就是去找频繁项集，而且需要相当地高效，像Apriori那样的速度肯定是不行的了。<br />   本文要介绍的是<strong>FP-growth算法</strong>，它被用于挖掘频繁项集，它把数据集存储为一个叫<strong>FP树</strong>的数据结构里，这样可以更高效地发现<strong>频繁项集</strong>或<strong>频繁项对</strong>。相比于Apriori对每个潜在的频繁项集都扫描数据集判定是否满足支持度，FP-growth算法只需要<strong>遍历两次</strong>数据库，因此它在大数据集上的速度显著优于Apriori。<br />   本文的内容和代码主要来源于《机器学习实战》，加入一些自己的理解和测试，有兴趣可以去看看原书。</p> <hr/> <h2 id="fp树">FP树</h2> <p><strong>FP</strong>即<strong>Frequent Pattern</strong>，FP树看上去就是一棵前缀树，根节点是空集，结点上是单个元素，保存了它在数据集中的出现次数，出现次数越多的元素越接近根。此外，结点之间通过链接（link）相连，只有相似元素会被连起来，连起来的元素又可以看成链表。同一个元素可以在FP树中多次出现，根据位置不同，对应着不同的频繁项集。可以为FP树设置最小支持度，过滤掉出现次数太少的元素。<br />   下面这个数据集构造FP树如下图所示。</p> <table> <thead> <tr> <th>instance id</th> <th align="center">elements</th> </tr> </thead> <tbody> <tr> <td>0</td> <td align="center">r, z, h, j, p</td> </tr> <tr> <td>1</td> <td align="center">z, y, x, w, v, u, t, s</td> </tr> <tr> <td>2</td> <td align="center">z</td> </tr> <tr> <td>3</td> <td align="center">r, x, n, o, s</td> </tr> <tr> <td>4</td> <td align="center">y, r, x, z, q, t, p</td> </tr> <tr> <td>5</td> <td align="center">y, z, x, e, q, s, t, m</td> </tr> </tbody> </table> <p><center><br /><img decoding="async" src="http://img.555519.xyz/uploads3/20220722/5f2dfe2c2cf748ffdd6c3060ec173263.jpg" alt="FP-growth 算法与Python实现" width="50%"/></center></p> <p>  这棵树每个结点上都是一个单独的元素，及其在路径中的出现次数，例如<code>"z:5"</code>表示集合<code>{z}</code>出现了5次，而<code>"x:3"</code>表示集合<code>{z,x}</code>出现了3次，这是路径相关的。</p> <hr/> <h2 id="fp树结点">FP树结点</h2> <p>  树结点定义如下，<code>name</code>存放结点名字，<code>count</code>用于计数，<code>nodeLink</code>用于连接相似结点（即图中箭头），<code>parent</code>用于存放父节点，用于回溯，<code>children</code>存放儿子结点（即图中实线）。<code>disp</code>仅用于输出调试。</p> <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span><span class="hljs-title">treeNode</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">__init__</span><span class="hljs-params">(self, nameValue, numOccur, parentNode)</span>:</span>         self.name = nameValue         self.count = numOccur         self.nodeLink =<span class="hljs-keyword">None</span>         self.parent = parentNode         self.children = {}<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">inc</span><span class="hljs-params">(self, numOccur)</span>:</span>         self.count += numOccur<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">disp</span><span class="hljs-params">(self, ind=<span class="hljs-number">1</span>)</span>:</span><span class="hljs-keyword">print</span><span class="hljs-string">'  '</span>*ind, self.name,<span class="hljs-string">' '</span>, self.count<span class="hljs-keyword">for</span> child<span class="hljs-keyword">in</span> self.children.values():             child.disp(ind+<span class="hljs-number">1</span>)</code></pre> <hr/> <h2 id="构建fp树">构建FP树</h2> <p>  为了能方便地访问FP树种每一个不同的元素，需要为每种元素（的链表）设置一个头（header），这个header除了指向指定元素的第一个结点外，还可以保存该元素在数据集中的总出现次数。</p> <p><center><br /><img decoding="async" src="http://img.555519.xyz/uploads3/20220722/fad5cdb213b79a4b0049c16d73d7ec0c.jpg" alt="FP-growth 算法与Python实现" width="60%"/></center></p> <p>  首先，遍历一次数据集，统计每个元素出现的次数，然后把出现次数较小的滤掉（例如选取最小支持度3，将出现次数小于3的元素滤除），然后对每个样本按照元素出现次数重排序。上面给出的数据集样例中，出现次数不小于3的元素有：z、r、x、y、s、t，滤除并重排后的样本如下所示。</p> <table> <thead> <tr> <th>instance id</th> <th align="center">elements</th> <th align="center">filtered &amp; sorted elements</th> </tr> </thead> <tbody> <tr> <td>0</td> <td align="center">r, z, h, j, p</td> <td align="center">r, z</td> </tr> <tr> <td>1</td> <td align="center">z, y, x, w, v, u, t, s</td> <td align="center">z, x, y, s, t</td> </tr> <tr> <td>2</td> <td align="center">z</td> <td align="center">z</td> </tr> <tr> <td>3</td> <td align="center">r, x, n, o, s</td> <td align="center">x, s, r</td> </tr> <tr> <td>4</td> <td align="center">y, r, x, z, q, t, p</td> <td align="center">z, x, y, r, t</td> </tr> <tr> <td>5</td> <td align="center">y, z, x, e, q, s, t, m</td> <td align="center">z, x, y, s, t</td> </tr> </tbody> </table> <p>  接着，构造FP树。从根节点∅开始，将过滤并排序后的样本一个个加入树中，若FP树不存在现有元素则添加分支，若存在则增加相应的值。下图给出了从根节点∅开始依次添加三个样本（过滤且排序）后FP的情况。</p> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220722/379f1aee002f62401974b473ab85d7ff.jpg" alt="FP-growth 算法与Python实现"></p> <p>  那么对于单个样本，FP树应该怎么生长呢？自然而然地想到递归。因为每个样本都是排序过的，频数高的频繁项集在前面，它总是更接近根结点，所以也可以把每个样本看成一棵子树，而我们要做的就是把子树添加到FP树里。因此每次只需判断第一个结点是否是根的儿子，若是则增加计数，若不是则增加分枝，然后递归调用构造FP树，传入第二个元素开始的子树即可。比如上例中往根节点∅增加样本<code>(z,r)</code>时，根没有<code>z</code>这个儿子，因此增加分支<code>z</code>。接着，只需递归地构造FP树，传入<code>(r)</code>，发现当前FP树<code>∅-z</code>也没有<code>r</code>这个儿子，因此增加分支<code>r</code>。最终递归返回，引入样本<code>(z,r)</code>后构造的FP树就是<code>∅-z-r</code>。<br />   下图详细地描述了这个过程，代码中<code>updateFPtree()</code>函数实现了这个功能。</p> <p><center><br /><img decoding="async" src="http://img.555519.xyz/uploads3/20220722/11c037b33b1d89f5da712ad61e6f9ede.jpg" alt="FP-growth 算法与Python实现" width="70%"/></center></p> <h3 id="fp树构造代码实现">FP树构造代码实现</h3> <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">updateHeader</span><span class="hljs-params">(nodeToTest, targetNode)</span>:</span><span class="hljs-keyword">while</span> nodeToTest.nodeLink !=<span class="hljs-keyword">None</span>:         nodeToTest = nodeToTest.nodeLink     nodeToTest.nodeLink = targetNode<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">updateFPtree</span><span class="hljs-params">(items, inTree, headerTable, count)</span>:</span><span class="hljs-keyword">if</span> items[<span class="hljs-number">0</span>]<span class="hljs-keyword">in</span> inTree.children:<span class="hljs-comment"># 判断items的第一个结点是否已作为子结点</span>         inTree.children[items[<span class="hljs-number">0</span>]].inc(count)<span class="hljs-keyword">else</span>:<span class="hljs-comment"># 创建新的分支</span>         inTree.children[items[<span class="hljs-number">0</span>]] = treeNode(items[<span class="hljs-number">0</span>], count, inTree)<span class="hljs-comment"># 更新相应频繁项集的链表，往后添加</span><span class="hljs-keyword">if</span> headerTable[items[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>] ==<span class="hljs-keyword">None</span>:             headerTable[items[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>] = inTree.children[items[<span class="hljs-number">0</span>]]<span class="hljs-keyword">else</span>:             updateHeader(headerTable[items[<span class="hljs-number">0</span>]][<span class="hljs-number">1</span>], inTree.children[items[<span class="hljs-number">0</span>]])<span class="hljs-comment"># 递归</span><span class="hljs-keyword">if</span> len(items) &gt;<span class="hljs-number">1</span>:         updateFPtree(items[<span class="hljs-number">1</span>::], inTree.children[items[<span class="hljs-number">0</span>]], headerTable, count)<span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">createFPtree</span><span class="hljs-params">(dataSet, minSup=<span class="hljs-number">1</span>)</span>:</span>     headerTable = {}<span class="hljs-keyword">for</span> trans<span class="hljs-keyword">in</span> dataSet:<span class="hljs-keyword">for</span> item<span class="hljs-keyword">in</span> trans:             headerTable[item] = headerTable.get(item,<span class="hljs-number">0</span>) + dataSet[trans]<span class="hljs-keyword">for</span> k<span class="hljs-keyword">in</span> headerTable.keys():<span class="hljs-keyword">if</span> headerTable[k] &lt; minSup:<span class="hljs-keyword">del</span>(headerTable[k])<span class="hljs-comment"># 删除不满足最小支持度的元素</span>     freqItemSet = set(headerTable.keys())<span class="hljs-comment"># 满足最小支持度的频繁项集</span><span class="hljs-keyword">if</span> len(freqItemSet) ==<span class="hljs-number">0</span>:<span class="hljs-keyword">return</span><span class="hljs-keyword">None</span>,<span class="hljs-keyword">None</span><span class="hljs-keyword">for</span> k<span class="hljs-keyword">in</span> headerTable:         headerTable[k] = [headerTable[k],<span class="hljs-keyword">None</span>]<span class="hljs-comment"># element: [count, node]</span>      retTree = treeNode(<span class="hljs-string">'Null Set'</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">None</span>)<span class="hljs-keyword">for</span> tranSet, count<span class="hljs-keyword">in</span> dataSet.items():<span class="hljs-comment"># dataSet：[element, count]</span>         localD = {}<span class="hljs-keyword">for</span> item<span class="hljs-keyword">in</span> tranSet:<span class="hljs-keyword">if</span> item<span class="hljs-keyword">in</span> freqItemSet:<span class="hljs-comment"># 过滤，只取该样本中满足最小支持度的频繁项</span>                 localD[item] = headerTable[item][<span class="hljs-number">0</span>]<span class="hljs-comment"># element : count</span><span class="hljs-keyword">if</span> len(localD) &gt;<span class="hljs-number">0</span>:<span class="hljs-comment"># 根据全局频数从大到小对单样本排序</span>             orderedItem = [v[<span class="hljs-number">0</span>]<span class="hljs-keyword">for</span> v<span class="hljs-keyword">in</span> sorted(localD.items(), key=<span class="hljs-keyword">lambda</span> p:p[<span class="hljs-number">1</span>], reverse=<span class="hljs-keyword">True</span>)]<span class="hljs-comment"># 用过滤且排序后的样本更新树</span>             updateFPtree(orderedItem, retTree, headerTable, count)<span class="hljs-keyword">return</span> retTree, headerTable</code></pre> <h3 id="测试实例">测试实例</h3> <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-comment"># 数据集</span><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">loadSimpDat</span><span class="hljs-params">()</span>:</span>     simDat = [[<span class="hljs-string">'r'</span>,<span class="hljs-string">'z'</span>,<span class="hljs-string">'h'</span>,<span class="hljs-string">'j'</span>,<span class="hljs-string">'p'</span>],               [<span class="hljs-string">'z'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'w'</span>,<span class="hljs-string">'v'</span>,<span class="hljs-string">'u'</span>,<span class="hljs-string">'t'</span>,<span class="hljs-string">'s'</span>],               [<span class="hljs-string">'z'</span>],               [<span class="hljs-string">'r'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'n'</span>,<span class="hljs-string">'o'</span>,<span class="hljs-string">'s'</span>],               [<span class="hljs-string">'y'</span>,<span class="hljs-string">'r'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'z'</span>,<span class="hljs-string">'q'</span>,<span class="hljs-string">'t'</span>,<span class="hljs-string">'p'</span>],               [<span class="hljs-string">'y'</span>,<span class="hljs-string">'z'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'e'</span>,<span class="hljs-string">'q'</span>,<span class="hljs-string">'s'</span>,<span class="hljs-string">'t'</span>,<span class="hljs-string">'m'</span>]]<span class="hljs-keyword">return</span> simDat<span class="hljs-comment"># 构造成 element : count 的形式</span><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">createInitSet</span><span class="hljs-params">(dataSet)</span>:</span>     retDict={}<span class="hljs-keyword">for</span> trans<span class="hljs-keyword">in</span> dataSet:         key = frozenset(trans)<span class="hljs-keyword">if</span> retDict.has_key(key):             retDict[frozenset(trans)] +=<span class="hljs-number">1</span><span class="hljs-keyword">else</span>:             retDict[frozenset(trans)] =<span class="hljs-number">1</span><span class="hljs-keyword">return</span> retDict  simDat = fpgrowth.loadSimpDat() initSet = fpgrowth.createInitSet(simDat) myFPtree, myHeaderTab = fpgrowth.createFPtree(initSet,<span class="hljs-number">3</span>)<span class="hljs-comment"># 最小支持度3</span> myFPtree.disp()</code></pre> <p>输出结果如下，构造出来的FP树与上面给出的图是等价的。</p> <pre class="prettyprint"><code class="language-python hljs">Null Set<span class="hljs-number">1</span>   x<span class="hljs-number">1</span>     s<span class="hljs-number">1</span>       r<span class="hljs-number">1</span>   z<span class="hljs-number">5</span>     x<span class="hljs-number">3</span>       y<span class="hljs-number">3</span>         s<span class="hljs-number">2</span>           t<span class="hljs-number">2</span>         r<span class="hljs-number">1</span>           t<span class="hljs-number">1</span>     r<span class="hljs-number">1</span></code></pre> <hr/> <h2 id="从fp树挖掘频繁项集">从FP树挖掘频繁项集</h2> <p>从FP挖掘频繁项集的步骤如下：</p> <ol> <li>从FP树提取条件模式基</li> <li>用条件模式基构造FP树</li> <li>重复1和2直到树只包含一个元素</li> </ol> <h3 id="提取条件模式基">提取条件模式基</h3> <p><strong>条件模式基</strong>（conditional pattern base）定义为以所查找元素为结尾的所有<strong>前缀路径</strong>（prefix path）的集合。我们要做的就是从header列表开始，针对每一个频繁项，都查找其对应的条件模式基。举个例子，如下图所示，元素<code>"r"</code>的前缀路径是<code>{z}</code>、<code>{z,x,y}</code>和<code>{x,s}</code>。同时，每一个路径要与起始元素的计数值关联。</p> <p><center><br /><img decoding="async" src="http://img.555519.xyz/uploads3/20220722/1dc32e4682cd1e733529ecfca6b2bdb7.jpg" alt="FP-growth 算法与Python实现" width="60%"/></center></p> <table> <thead> <tr> <th>频繁项</th> <th align="center">前缀路径集合（条件模式基）</th> </tr> </thead> <tbody> <tr> <td>z</td> <td align="center">{} 5</td> </tr> <tr> <td>r</td> <td align="center">{x,s} 1, {z,x,y} 1, {z} 1</td> </tr> <tr> <td>x</td> <td align="center">{z} 3, {} 1</td> </tr> <tr> <td>y</td> <td align="center">{z,x} 3</td> </tr> <tr> <td>s</td> <td align="center">{z,x,y} 2, {x} 1</td> </tr> <tr> <td>t</td> <td align="center">{z,x,y,s} 2, {z,x,y,r} 1</td> </tr> </tbody> </table> <h4 id="代码实现查找以目标元素结尾的所有路径条件模式基">代码实现查找以目标元素结尾的所有路径（条件模式基）</h4> <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-comment"># 递归回溯</span><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">ascendFPtree</span><span class="hljs-params">(leafNode, prefixPath)</span>:</span><span class="hljs-keyword">if</span> leafNode.parent !=<span class="hljs-keyword">None</span>:         prefixPath.append(leafNode.name)         ascendFPtree(leafNode.parent, prefixPath)<span class="hljs-comment"># 条件模式基</span><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">findPrefixPath</span><span class="hljs-params">(basePat, myHeaderTab)</span>:</span>     treeNode = myHeaderTab[basePat][<span class="hljs-number">1</span>]<span class="hljs-comment"># basePat在FP树中的第一个结点</span>     condPats = {}<span class="hljs-keyword">while</span> treeNode !=<span class="hljs-keyword">None</span>:         prefixPath = []         ascendFPtree(treeNode, prefixPath)<span class="hljs-comment"># prefixPath是倒过来的，从treeNode开始到根</span><span class="hljs-keyword">if</span> len(prefixPath) &gt;<span class="hljs-number">1</span>:             condPats[frozenset(prefixPath[<span class="hljs-number">1</span>:])] = treeNode.count<span class="hljs-comment"># 关联treeNode的计数</span>         treeNode = treeNode.nodeLink<span class="hljs-comment"># 下一个basePat结点</span><span class="hljs-keyword">return</span> condPats</code></pre> <h4 id="测试用例">测试用例</h4> <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-keyword">print</span> fpgrowth.findPrefixPath(<span class="hljs-string">'z'</span>, myHeaderTab)<span class="hljs-keyword">print</span> fpgrowth.findPrefixPath(<span class="hljs-string">'r'</span>, myHeaderTab)<span class="hljs-keyword">print</span> fpgrowth.findPrefixPath(<span class="hljs-string">'x'</span>, myHeaderTab)</code></pre> <p>输出结果与上表是一致的，区别在于省略了空集。</p> <pre class="prettyprint"><code class="language-python hljs">{} {frozenset([<span class="hljs-string">'x'</span>,<span class="hljs-string">'s'</span>]):<span class="hljs-number">1</span>, frozenset([<span class="hljs-string">'z'</span>]):<span class="hljs-number">1</span>, frozenset([<span class="hljs-string">'y'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'z'</span>]):<span class="hljs-number">1</span>} {frozenset([<span class="hljs-string">'z'</span>]):<span class="hljs-number">3</span>}</code></pre> <h3 id="创建条件fp树">创建条件FP树</h3> <p>  对每一个频繁项，都建立一棵条件FP树。上面我们对每一个频繁项提取了条件模式基，现在就用它作为输入数据，即把每一个前缀路径当成一个样本，调用<code>createFPtree()</code>构造一棵FP树，即<strong>条件FP树</strong>。然后，对这个条件FP树，递归地挖掘。由于<code>createFPtree()</code>中含有过滤的功能，因此最终总能获得所有满足最小支持度的频繁项，即我们所需要的频繁项集。</p> <p><center><br /><img decoding="async" src="http://img.555519.xyz/uploads3/20220722/da1ce0d66d837b1bac6a2876578b1bab.jpg" alt="FP-growth 算法与Python实现" width="70%"/></center></p> <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">mineFPtree</span><span class="hljs-params">(inTree, headerTable, minSup, preFix, freqItemList)</span>:</span><span class="hljs-comment"># 最开始的频繁项集是headerTable中的各元素</span>     bigL = [v[<span class="hljs-number">0</span>]<span class="hljs-keyword">for</span> v<span class="hljs-keyword">in</span> sorted(headerTable.items(), key=<span class="hljs-keyword">lambda</span> p:p[<span class="hljs-number">1</span>])]<span class="hljs-comment"># 根据频繁项的总频次排序</span><span class="hljs-keyword">for</span> basePat<span class="hljs-keyword">in</span> bigL:<span class="hljs-comment"># 对每个频繁项</span>         newFreqSet = preFix.copy()         newFreqSet.add(basePat)         freqItemList.append(newFreqSet)         condPattBases = findPrefixPath(basePat, headerTable)<span class="hljs-comment"># 当前频繁项集的条件模式基</span>         myCondTree, myHead = createFPtree(condPattBases, minSup)<span class="hljs-comment"># 构造当前频繁项的条件FP树</span><span class="hljs-keyword">if</span> myHead !=<span class="hljs-keyword">None</span>:<span class="hljs-comment"># print 'conditional tree for: ', newFreqSet</span><span class="hljs-comment"># myCondTree.disp(1)</span>             mineFPtree(myCondTree, myHead, minSup, newFreqSet, freqItemList)<span class="hljs-comment"># 递归挖掘条件FP树</span></code></pre> <h4 id="测试">测试</h4> <p>获取数据集中出现次数不小于3的组合。</p> <pre class="prettyprint"><code class="language-python hljs">simDat = fpgrowth.loadSimpDat() initSet = fpgrowth.createInitSet(simDat) myFPtree, myHeaderTab = fpgrowth.createFPtree(initSet,<span class="hljs-number">3</span>)  freqItems = [] fpgrowth.mineFPtree(myFPtree, myHeaderTab,<span class="hljs-number">3</span>, set([]), freqItems)<span class="hljs-keyword">for</span> x<span class="hljs-keyword">in</span> freqItems:<span class="hljs-keyword">print</span> x</code></pre> <p>输出结果，可以对照一下，这些组合出现的次数都至少为3。</p> <pre class="prettyprint"><code class="language-python hljs">set([<span class="hljs-string">'y'</span>]) set([<span class="hljs-string">'y'</span>,<span class="hljs-string">'x'</span>]) set([<span class="hljs-string">'y'</span>,<span class="hljs-string">'z'</span>]) set([<span class="hljs-string">'y'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'z'</span>]) set([<span class="hljs-string">'s'</span>]) set([<span class="hljs-string">'x'</span>,<span class="hljs-string">'s'</span>]) set([<span class="hljs-string">'t'</span>]) set([<span class="hljs-string">'y'</span>,<span class="hljs-string">'t'</span>]) set([<span class="hljs-string">'x'</span>,<span class="hljs-string">'t'</span>]) set([<span class="hljs-string">'y'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'t'</span>]) set([<span class="hljs-string">'z'</span>,<span class="hljs-string">'t'</span>]) set([<span class="hljs-string">'x'</span>,<span class="hljs-string">'z'</span>,<span class="hljs-string">'t'</span>]) set([<span class="hljs-string">'y'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'z'</span>,<span class="hljs-string">'t'</span>]) set([<span class="hljs-string">'y'</span>,<span class="hljs-string">'z'</span>,<span class="hljs-string">'t'</span>]) set([<span class="hljs-string">'r'</span>]) set([<span class="hljs-string">'x'</span>]) set([<span class="hljs-string">'x'</span>,<span class="hljs-string">'z'</span>]) set([<span class="hljs-string">'z'</span>])</code></pre> <hr/> <h2 id="代码中存在的bug">代码中存在的bug</h2> <p>  出于测试，我把<code>createFPtree</code>中的最小支持度改成了<code>2</code>，意思是允许出现次数为2的单元素频繁项<code>p</code>和<code>q</code>参与进来，理论上<code>mineFPtree</code>生成的频繁项集应当只增无减才对，然而结果却是减少了，而且频繁项<code>{y,x,z,t}</code>不见了，说明代码有问题。<br />   经过排查，我认为错误出在按照频次对样本过滤与排序那里。如果有两个元素频次相同，python2的稳定排序会保持他们在原本字典中的顺序。为了解决这个问题，需要修改<code>createFPtree</code>函数中对样本排序的部分，使得两元素在频次相同时按照字母顺序排序。</p> <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">createFPtree</span><span class="hljs-params">(dataSet, minSup=<span class="hljs-number">1</span>)</span>:</span>     ...<span class="hljs-keyword">if</span> len(localD) &gt;<span class="hljs-number">0</span>:<span class="hljs-comment"># 根据全局频数从大到小对单样本排序</span>             orderedItem = [v[<span class="hljs-number">0</span>]<span class="hljs-keyword">for</span> v<span class="hljs-keyword">in</span> sorted(localD.iteritems(), key=<span class="hljs-keyword">lambda</span> p:(p[<span class="hljs-number">1</span>], -ord(p[<span class="hljs-number">0</span>])), reverse=<span class="hljs-keyword">True</span>)]</code></pre> <hr/> <h2 id="示例-从新闻网站点击流中挖掘">示例： 从新闻网站点击流中挖掘</h2> <p>  数据集kosarak.dat可以从<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=http://fimi.ua.ac.be/data/"  rel="nofollow">这里</a>下载，它的每一条记录是某个用户浏览过的新闻报道，总共99w条样本，新闻报道被编码成index。使用FP-growth，查看有哪些新闻报道集合被超过10w人浏览。</p> <pre class="prettyprint"><code class="language-python hljs"><span class="hljs-comment"># 准备数据</span><span class="hljs-keyword">with</span> open(<span class="hljs-string">"./data/kosarak.dat"</span>,<span class="hljs-string">"rb"</span>)<span class="hljs-keyword">as</span> f:     parsedDat = [line.split()<span class="hljs-keyword">for</span> line<span class="hljs-keyword">in</span> f.readlines()] initSet = fpgrowth.createInitSet(parsedDat)<span class="hljs-comment"># 用数据集构造FP树，最小支持度10w</span> myFPtree, myHeaderTab = fpgrowth.createFPtree(initSet,<span class="hljs-number">100000</span>)<span class="hljs-comment"># 挖掘FP树</span> freqItems = [] fpgrowth.mineFPtree(myFPtree, myHeaderTab,<span class="hljs-number">100000</span>, set([]), freqItems)<span class="hljs-keyword">for</span> x<span class="hljs-keyword">in</span> freqItems:<span class="hljs-keyword">print</span> x</code></pre> <p>输出结果如下，在我的macbook上，整个过程仅耗时13秒。</p> <pre class="prettyprint"><code class="language-python hljs">set([<span class="hljs-string">'1'</span>]) set([<span class="hljs-string">'1'</span>,<span class="hljs-string">'6'</span>]) set([<span class="hljs-string">'11'</span>]) set([<span class="hljs-string">'11'</span>,<span class="hljs-string">'3'</span>]) set([<span class="hljs-string">'11'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'6'</span>]) set([<span class="hljs-string">'11'</span>,<span class="hljs-string">'6'</span>]) set([<span class="hljs-string">'3'</span>]) set([<span class="hljs-string">'3'</span>,<span class="hljs-string">'6'</span>]) set([<span class="hljs-string">'6'</span>])</code></pre> <p>针对上面提到的bug，由于kosarak.dat中的元素都是字符串化的整数，故<code>createFPtree</code>中排序的部分应该修改成：</p> <pre class="prettyprint"><code class="language-python hljs">... orderedItem = [v[<span class="hljs-number">0</span>]<span class="hljs-keyword">for</span> v<span class="hljs-keyword">in</span> sorted(localD.iteritems(), key=<span class="hljs-keyword">lambda</span> p:(p[<span class="hljs-number">1</span>], int(p[<span class="hljs-number">0</span>])), reverse=<span class="hljs-keyword">True</span>)]</code></pre> <hr/> <h2 id="总结">总结</h2> <p>  FP-growth其实是一种特殊的数据结构的应用，本质上是某种前缀树+相似元素链表的结构。FP-growth算法提供了一种相对更快的发现频繁项集的方法，它之所以快，是因为它只遍历1次数据集，即可将整个数据集构造成一棵FP树，之后从FP树中发现频繁项集。提取出频繁项集之后，就可以进一步挖掘关联规则，比如Apriori算法中的方法（详情可见<a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://blog.csdn.net/songbinxu/article/details/80398819"  rel="nofollow">这里</a>）。<br />   书中算法的实现大量使用了递归，这里可能有个问题，就是递归层数过深。</p> <hr/> <h2 id="完整代码">完整代码</h2> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://github.com/SongDark/FPgrowth"  rel="nofollow">https://github.com/SongDark/FPgrowth</a></p> <hr/> <h2 id="参考资料">参考资料</h2> <p>《机器学习实战》<br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://blog.csdn.net/leo_xu06/article/details/51332428"  rel="nofollow">FP-growth算法高效发现频繁项集（Python代码）</a></p> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-25112.htm">MySQL数据库之数据表操作_Mysql</a></p>
                                        <p>下一个：<a href="/news/article-25580.htm">2021年河南动物疫苗中标公告公布时间（河南省2021年动物疫苗中标公告）</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2024-7-6-node-share.htm" title="7月6日|Clash/SSR/V2ray/Shadowrocket每天更新21.2M/S免费节点订阅链接">7月6日|Clash/SSR/V2ray/Shadowrocket每天更新21.2M/S免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-3-19-node-share.htm" title="3月19日18.7M/S|Clash/Shadowrocket/SSR/V2ray免费节点每天更新订阅链接">3月19日18.7M/S|Clash/Shadowrocket/SSR/V2ray免费节点每天更新订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-6-18-clash-v2ray-ss-ssr.htm" title="6月18日|SSR/V2ray/Shadowrocket/Clash每天更新18.8M/S免费节点订阅链接">6月18日|SSR/V2ray/Shadowrocket/Clash每天更新18.8M/S免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-5-17-free-clash.htm" title="5月17日|Clash/V2ray/Shadowrocket/SSR每天更新20.9M/S免费节点订阅链接">5月17日|Clash/V2ray/Shadowrocket/SSR每天更新20.9M/S免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-6-23-free-ssr-subscribe.htm" title="6月23日|Shadowrocket/SSR/Clash/V2ray每天更新21M/S免费节点订阅链接">6月23日|Shadowrocket/SSR/Clash/V2ray每天更新21M/S免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-6-27-node-share-links.htm" title="6月27日|V2ray/Shadowrocket/SSR/Clash每天更新22M/S免费节点订阅链接">6月27日|V2ray/Shadowrocket/SSR/Clash每天更新22M/S免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-7-7-clash-v2ray-ss-ssr.htm" title="7月7日|Clash/V2ray/SSR/Shadowrocket每天更新22.3M/S免费节点订阅链接">7月7日|Clash/V2ray/SSR/Shadowrocket每天更新22.3M/S免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-4-29-free-clash.htm" title="4月29日|Clash/SSR/Shadowrocket/V2ray每天更新22.4M/S免费节点订阅链接">4月29日|Clash/SSR/Shadowrocket/V2ray每天更新22.4M/S免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-3-31-free-v2ray-subscribe.htm" title="3月31日|SSR/Shadowrocket/Clash/V2ray每天更新22.3M/S免费节点订阅链接">3月31日|SSR/Shadowrocket/Clash/V2ray每天更新22.3M/S免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-6-14-free-v2ray-subscribe.htm" title="6月14日|Shadowrocket/SSR/V2ray/Clash每天更新22.6M/S免费节点订阅链接">6月14日|Shadowrocket/SSR/V2ray/Clash每天更新22.6M/S免费节点订阅链接</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">48</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">34</span> <a href="/date/2024-11/" title="2024-11 归档">2024-11</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-10/" title="2024-10 归档">2024-10</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2024-09/" title="2024-09 归档">2024-09</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-08/" title="2024-08 归档">2024-08</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">27</span> <a href="/date/2024-07/" title="2024-07 归档">2024-07</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">29</span> <a href="/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">27</span> <a href="/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">13</span> <a href="/date/2024-03/" title="2024-03 归档">2024-03</a></h4>
            </li>
                    </ul>
    </div>
</div>


                </div>
            </div>
        </div>
    </div>
    <!-- about sectuion end -->
        <!-- copyright section start -->
    <div class="copyright_section">
        <div class="container">
            <div class="row">
                <div class="col-sm-12">
                    <p class="copyright_text">
                            ClashNodesFree免费订阅站 版权所有
                            <br />
                            Powered by WordPress
                    </p>
                </div>
            </div>
        </div>
    </div>
    <!-- copyright section end -->
    <!-- Javascript files-->
    <script src="/assets/website/js/frontend/clashnodesfree/jquery.min.js"></script>
    <script src="/assets/website/js/frontend/clashnodesfree/popper.min.js"></script>
    <script src="/assets/website/js/frontend/clashnodesfree/bootstrap.bundle.min.js"></script>
    <script src="/assets/website/js/frontend/clashnodesfree/jquery-3.0.0.min.js"></script>
    <script src="/assets/website/js/frontend/clashnodesfree/plugin.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>